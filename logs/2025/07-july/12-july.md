12-07-2025


## Progress
* Learned core concepts of abstract classes and abstract methods.

* Practiced hands-on by creating a payroll system using Employee, Developer, and Manager classes.

* Understood how polymorphism allows handling multiple subclasses through a single abstract reference.

* Implemented method overriding and correctly used constructors, class variables, and dynamic method calls.

* Gained clarity on using getClass() vs this.getClass() vs getSimpleName().

## Challenges
* Initially mismatched method signatures while overriding (int vs double return type).

* Forgot to call method with () (e.g., e.calculateSalary instead of e.calculateSalary()).

* Confused between local method parameters vs class fields (s, b vs basicSalary, bonus).

* Felt that using abstract classes seemed unnecessary at first due to similar method logic in subclasses.

## Key Takeaway
Abstract classes aren't about reducing typing — they’re about enforcing structure, enabling polymorphism, and future-proofing large codebases. Even if subclass logic looks similar now, abstract classes lay the foundation for clean, scalable, and flexible design.
